

## 概念比较

- 协程函数（coroutine function），由`async def`定义的函数。
    - 对比1：普通函数是由`def`定义的
    - 对比2：协程函数不是协程对象，协程对象是协程函数的实例。
- 原生协程（coroutine），也是协程对象，异步函数调用（call）的返回对象。
    - 对比：普通函数调用的返回对象就是`return`语句的返回对象
- 生成器（generator），含有`yield`或`yield from`语句的普通函数。
    - 含有`yield`语句的生成器是基础生成器，实现生成器的逆向函数作用。
    - 含有`yield`语句的生成器是代理生成器，代理生成器改善了复杂场景下生成器的使用模式。
- 生成器协程（gen-coroutine），使用`@types.coroutine`装饰的生成器。
- 可等待对象（awaitable）包括
    - 原生协程（coroutine）
    - 生成器协程（gen-coroutine）
    - 定义了特殊方法`__await__()`的类型实例。

|                  | 原生协程                    | 基础生成器                 | 代理生成器                        | 生成器协程                                  |
|------------------|-------------------------|-----------------------|------------------------------|----------------------------------------|
| 标识语法             | `async def`             | `yield`               | `yield from`                 | `@types.coroutine`                     |
| 类型方法`send()`     | 支持                      | 支持                    | 支持                           | 支持                                     |
| 类型方法`thow()`     | 支持                      | 支持                    | 支持                           | 支持                                     |
| 类型方法`close()`    | 支持                      | 支持                    | 支持                           | 支持                                     |
| 类型方法`__iter__()` | --                      | 支持                    | 支持                           | 支持                                     |
| 类型方法`__next__()` | --                      | 支持                    | 支持                           | 支持                                     |
| 调用与跳转            | `r = await [awaitable]` | `r = yield [anyting]` | `r = yield from [generator]` | `r = yield from [generator/awaitable]` |


### 常规函数调用与指令跳转

函数调用时，也就是从一个过程跳转到另一个过程，会伴随改变程序计数器PC与当前的函数栈空间，
程序计数器的变化意味着指令跳转。

常规函数调用时，指令跳转方式两次，一次时进入被调用函数时，另一次是从被调用函数返回时。
而且，在进入被调用函数时，需要为被调函数构建函数栈空间；当从被调函数返回时，需要释放被调函数的函数栈空间。
例如下面这段示例代码中，调用跳转发生在：

1. 函数`main()`调用`func()`，伴随着新建立func的函数栈空间，操作内部变量`x`
2. 从被调函数`func()`返回`main()`，伴随着释放func的函数空间

```python
def func():
    x = 0
    return x


def main():
    return func()
```

### 协程调用与指令跳转

协程、生成器的情况稍微复杂些，与常规函数调用有相似点，也有不同点。

第一，`await`与`yield from`语句执行的函数调用看起来与常规函数类似。
例如下面这段示例代码中。

1. 函数`main()`执行`await a_func()`，伴随着协程a_func()的初始化，以及指令跳转
2. 从`a_func()`返回`main()`是，协程a_func()空间释放，指令跳转

```python
async def a_func():
    x = 0
    return x


async def main():
    await a_func()
```

第二，`yield`语句是与常规函数不同的调用方式。
常规函数的函数栈空间的构建、释放与控制指令进入、离开函数一同发生。
生成器函数的这两者是分类的：

（1）生成器函数在调用时，创建一个生成器对象，相当于构建了生成器运行的栈空间。但未执行函数代码，即指令并没有跳转。
（2）开始生成器对象的执行，是`next()`或者`send()`方法，此时指令发生了跳转。因为生成器栈空间已经准备好，所以此时不需要准备栈空间。
（3）指令进入生成器执行至`yield`语句时，指令返回至调用者。与常规函数返回时释放栈空间不同，此时栈空间不释放
（4）若指令运行至生成器对象的结束`return`时，生成器对象将被清理，栈空间释放。

```python
def gen():
    yield 1
    yield 2
    return


def main():
    g = gen()
    print(next(g))
    print(next(g))
```

第三，由于python协程的底层是`yield`语句机制，那么所有协程对象的运行时栈与指令的进入、离开是分离的

## 过程运行时栈空间

结论：协程运行时发生多次指令进入与返回，操作相同的运行时栈空间，栈空间数据前后保持一致。

常规函数栈结构，LIFO先进后出

## 协程暂停与恢复的时机

- 等待IO，(`yield`)
- 等待子协程执行完毕，由(`yield from`)



