---
title: "Python asyncio 协程创建与使用"
---

前文背景：「[异步：从并发到Python协程](https://daxtonwings.github.io/feathers/2024/04/19/from-concurrency-to-python-coroutine.html)」

* **[概念比较](#概念比较)**
    * [什么是并发](#什么是并发)
    * [为什么并发](#为什么要并发)

## 概念比较

- 协程函数（coroutine function），由`async def`定义的函数。
  - 对比1：普通函数是由`def`定义的
  - 对比2：协程函数不是协程对象，协程对象是协程函数的实例。
- 原生协程（coroutine），也是协程对象，异步函数调用（call）的返回对象。
  - 对比：普通函数调用的返回对象就是`return`语句的返回对象
- 生成器（generator），含有`yield`或`yield from`语句的普通函数。
  - 含有`yield`语句的生成器是基础生成器，实现生成器的逆向函数作用。
  - 含有`yield`语句的生成器是代理生成器，代理生成器改善了复杂场景下生成器的使用模式。
- 生成器协程（gen-coroutine），使用`@types.coroutine`装饰的生成器。
- 可等待对象（awaitable）包括
  - 原生协程（coroutine）
  - 生成器协程（gen-coroutine）
  - 定义了特殊方法`__await__()`的类型实例。

|             | 原生协程                  | 基础生成器                 | 代理生成器                | 生成器协程                                  |
|-------------|-----------------------|-----------------------|----------------------|----------------------------------------|
| 标识语法        | `async def`           | `yield`               | `yield from`       | `@types.coroutine`                     |
| 类型方法`send()` | 支持                    | 支持                    | 支持                 | 支持                                     |
| 类型方法`thow()` | 支持                    | 支持                    | 支持                 | 支持                                     |
| 类型方法`close()` | 支持                    | 支持                    | 支持                 | 支持                                     |
| 类型方法`__iter__()` | --                    | 支持                    | 支持                 | 支持                                     |
| 类型方法`__next__()` | --                    | 支持                    | 支持                 | 支持                                     |
| 调用与跳转       | `r = await [awaitable]` | `r = yield [anyting]` | `r = yield from [generator]` | `r = yield from [generator/awaitable]` |


### 常规函数调用与指令跳转

函数调用时，也就是从一个过程跳转到另一个过程，会伴随改变程序计数器PC与当前的函数栈空间，
程序计数器的变化意味着指令跳转。

常规函数调用时，指令跳转方式两次，一次时进入被调用函数时，另一次是从被调用函数返回时。
此外，在进入被调用函数时，需要为被调函数构建函数栈空间；
当从被调函数返回时，需要释放被调函数的函数栈空间。
例如下面这段示例代码中，调用跳转发生在：
1. 函数`main()`调用`foo()`，伴随着新建立foo的函数栈空间，操作内部变量`x`
2. 从被调函数`foo()`返回`main()`，伴随着释放foo的函数空间

```python
def foo():
    x = 0
    return x 

def main():
    return foo()
```

### 协程调用与指令跳转

协程、生成器的情况稍微复杂些，与常规函数调用有相似点，也有不同点。

第一，`await`与`yield from`语句执行的函数调用与常规函数类似。
例如下面这段示例代码中。
1. 函数`main()`执行`await foo()`，伴随着协程foo()的初始化，以及指令跳转
2. 从`foo()`返回`main()`是，协程foo()空间释放，指令跳转

```python
async def foo():
    x = 0
    return x

async def main():
    await foo()

```



从暂停/恢复点语法逻辑部分比较，协程（包括原生协程、生成器协程）与代理生成器暂停点的语法类似。
既，协程的`await`语句不是控制权发生转移之处，类比`yield from`不是协程控制权转移之处。